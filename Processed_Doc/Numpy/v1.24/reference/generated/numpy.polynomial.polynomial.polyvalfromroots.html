
<h1>numpy.polynomial.polynomial.polyvalfromroots<a class="headerlink" href="#numpy-polynomial-polynomial-polyvalfromroots" title="Permalink to this heading">#</a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="numpy.polynomial.polynomial.polyvalfromroots">
<span class="sig-prename descclassname"><span class="pre">polynomial.polynomial.</span></span><span class="sig-name descname"><span class="pre">polyvalfromroots</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tensor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/numpy/numpy/blob/v1.24.0/numpy/polynomial/polynomial.py#L760-L845"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#numpy.polynomial.polynomial.polyvalfromroots" title="Permalink to this definition">#</a></dt>
<dd><p>Evaluate a polynomial specified by its roots at points x.</p>
<p>If <em class="xref py py-obj">r</em> is of length <em class="xref py py-obj">N</em>, this function returns the value</p>
<div class="math notranslate nohighlight">
\[p(x) = \prod_{n=1}^{N} (x - r_n)\]</div>
<p>The parameter <em class="xref py py-obj">x</em> is converted to an array only if it is a tuple or a
list, otherwise it is treated as a scalar. In either case, either <em class="xref py py-obj">x</em>
or its elements must support multiplication and addition both with
themselves and with the elements of <em class="xref py py-obj">r</em>.</p>
<p>If <em class="xref py py-obj">r</em> is a 1-D array, then <em class="xref py py-obj">p(x)</em> will have the same shape as <em class="xref py py-obj">x</em>.  If <em class="xref py py-obj">r</em>
is multidimensional, then the shape of the result depends on the value of
<em class="xref py py-obj">tensor</em>. If <em class="xref py py-obj">tensor</em> is <code class="docutils literal notranslate"><span class="pre">True</span></code> the shape will be r.shape[1:] + x.shape;
that is, each polynomial is evaluated at every value of <em class="xref py py-obj">x</em>. If <em class="xref py py-obj">tensor</em> is
<code class="docutils literal notranslate"><span class="pre">False</span></code>, the shape will be r.shape[1:]; that is, each polynomial is
evaluated only for the corresponding broadcast value of <em class="xref py py-obj">x</em>. Note that
scalars have shape (,).</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.12.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like, compatible object</span></dt><dd><p>If <em class="xref py py-obj">x</em> is a list or tuple, it is converted to an ndarray, otherwise
it is left unchanged and treated as a scalar. In either case, <em class="xref py py-obj">x</em>
or its elements must support addition and multiplication with
with themselves and with the elements of <em class="xref py py-obj">r</em>.</p>
</dd>
<dt><strong>r</strong><span class="classifier">array_like</span></dt><dd><p>Array of roots. If <em class="xref py py-obj">r</em> is multidimensional the first index is the
root index, while the remaining indices enumerate multiple
polynomials. For instance, in the two dimensional case the roots
of each polynomial may be thought of as stored in the columns of <em class="xref py py-obj">r</em>.</p>
</dd>
<dt><strong>tensor</strong><span class="classifier">boolean, optional</span></dt><dd><p>If True, the shape of the roots array is extended with ones on the
right, one for each dimension of <em class="xref py py-obj">x</em>. Scalars have dimension 0 for this
action. The result is that every column of coefficients in <em class="xref py py-obj">r</em> is
evaluated for every element of <em class="xref py py-obj">x</em>. If False, <em class="xref py py-obj">x</em> is broadcast over the
columns of <em class="xref py py-obj">r</em> for the evaluation.  This keyword is useful when <em class="xref py py-obj">r</em> is
multidimensional. The default value is True.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>values</strong><span class="classifier">ndarray, compatible object</span></dt><dd><p>The shape of the returned array is described above.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="numpy.polynomial.polynomial.polyroots.html#numpy.polynomial.polynomial.polyroots" title="numpy.polynomial.polynomial.polyroots"><code class="xref py py-obj docutils literal notranslate"><span class="pre">polyroots</span></code></a>, <a class="reference internal" href="numpy.polynomial.polynomial.polyfromroots.html#numpy.polynomial.polynomial.polyfromroots" title="numpy.polynomial.polynomial.polyfromroots"><code class="xref py py-obj docutils literal notranslate"><span class="pre">polyfromroots</span></code></a>, <a class="reference internal" href="numpy.polyval.html#numpy.polyval" title="numpy.polyval"><code class="xref py py-obj docutils literal notranslate"><span class="pre">polyval</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.polynomial.polynomial</span> <span class="kn">import</span> <span class="n">polyvalfromroots</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polyvalfromroots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polyvalfromroots</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">array([[-0.,   0.],</span>
<span class="go">       [ 6.,  24.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># multidimensional coefficients</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="c1"># each column of r defines one polynomial</span>
<span class="go">array([[-2, -1],</span>
<span class="go">       [ 0,  1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polyvalfromroots</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">tensor</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[-0.,  3.],</span>
<span class="go">       [ 3., 0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polyvalfromroots</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">tensor</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([-0.,  0.])</span>
</pre></div>
</div>
</dd></dl>

