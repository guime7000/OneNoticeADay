
<h1>numpy.quantile<a class="headerlink" href="#numpy-quantile" title="Permalink to this heading">#</a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="numpy.quantile">
<span class="sig-prename descclassname"><span class="pre">numpy.</span></span><span class="sig-name descname"><span class="pre">quantile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interpolation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/numpy/numpy/blob/v1.24.0/numpy/lib/function_base.py#L4214-L4462"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#numpy.quantile" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the q-th quantile of the data along the specified axis.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.15.0.</span></p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input array or object that can be converted to an array.</p>
</dd>
<dt><strong>q</strong><span class="classifier">array_like of float</span></dt><dd><p>Quantile or sequence of quantiles to compute, which must be between
0 and 1 inclusive.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{int, tuple of int, None}, optional</span></dt><dd><p>Axis or axes along which the quantiles are computed. The default is
to compute the quantile(s) along a flattened version of the array.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must have
the same shape and buffer length as the expected output, but the
type (of the output) will be cast if necessary.</p>
</dd>
<dt><strong>overwrite_input</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, then allow the input array <em class="xref py py-obj">a</em> to be modified by
intermediate calculations, to save memory. In this case, the
contents of the input <em class="xref py py-obj">a</em> after this function completes is
undefined.</p>
</dd>
<dt><strong>method</strong><span class="classifier">str, optional</span></dt><dd><p>This parameter specifies the method to use for estimating the
quantile.  There are many different methods, some unique to NumPy.
See the notes for explanation.  The options sorted by their R type
as summarized in the H&amp;F paper <a class="reference internal" href="#re01cd3f3acfe-1" id="id1">[1]</a> are:</p>
<ol class="arabic simple">
<li><p>‘inverted_cdf’</p></li>
<li><p>‘averaged_inverted_cdf’</p></li>
<li><p>‘closest_observation’</p></li>
<li><p>‘interpolated_inverted_cdf’</p></li>
<li><p>‘hazen’</p></li>
<li><p>‘weibull’</p></li>
<li><p>‘linear’  (default)</p></li>
<li><p>‘median_unbiased’</p></li>
<li><p>‘normal_unbiased’</p></li>
</ol>
<p>The first three methods are discontinuous.  NumPy further defines the
following discontinuous variations of the default ‘linear’ (7.) option:</p>
<ul class="simple">
<li><p>‘lower’</p></li>
<li><p>‘higher’,</p></li>
<li><p>‘midpoint’</p></li>
<li><p>‘nearest’</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.22.0: </span>This argument was previously called “interpolation” and only
offered the “linear” default and last four options.</p>
</div>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left in
the result as dimensions with size one. With this option, the
result will broadcast correctly against the original array <em class="xref py py-obj">a</em>.</p>
</dd>
<dt><strong>interpolation</strong><span class="classifier">str, optional</span></dt><dd><p>Deprecated name for the method keyword argument.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.22.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>quantile</strong><span class="classifier">scalar or ndarray</span></dt><dd><p>If <em class="xref py py-obj">q</em> is a single quantile and <em class="xref py py-obj">axis=None</em>, then the result
is a scalar. If multiple quantiles are given, first axis of
the result corresponds to the quantiles. The other axes are
the axes that remain after the reduction of <em class="xref py py-obj">a</em>. If the input
contains integers or floats smaller than <code class="docutils literal notranslate"><span class="pre">float64</span></code>, the output
data-type is <code class="docutils literal notranslate"><span class="pre">float64</span></code>. Otherwise, the output data-type is the
same as that of the input. If <em class="xref py py-obj">out</em> is specified, that array is
returned instead.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="numpy.mean.html#numpy.mean" title="numpy.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="numpy.percentile.html#numpy.percentile" title="numpy.percentile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">percentile</span></code></a></dt><dd><p>equivalent to quantile, but with q in the range [0, 100].</p>
</dd>
<dt><a class="reference internal" href="numpy.median.html#numpy.median" title="numpy.median"><code class="xref py py-obj docutils literal notranslate"><span class="pre">median</span></code></a></dt><dd><p>equivalent to <code class="docutils literal notranslate"><span class="pre">quantile(...,</span> <span class="pre">0.5)</span></code></p>
</dd>
<dt><a class="reference internal" href="numpy.nanquantile.html#numpy.nanquantile" title="numpy.nanquantile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanquantile</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Given a vector <code class="docutils literal notranslate"><span class="pre">V</span></code> of length <code class="docutils literal notranslate"><span class="pre">n</span></code>, the q-th quantile of <code class="docutils literal notranslate"><span class="pre">V</span></code> is
the value <code class="docutils literal notranslate"><span class="pre">q</span></code> of the way from the minimum to the maximum in a
sorted copy of <code class="docutils literal notranslate"><span class="pre">V</span></code>. The values and distances of the two nearest
neighbors as well as the <em class="xref py py-obj">method</em> parameter will determine the
quantile if the normalized ranking does not match the location of
<code class="docutils literal notranslate"><span class="pre">q</span></code> exactly. This function is the same as the median if <code class="docutils literal notranslate"><span class="pre">q=0.5</span></code>, the
same as the minimum if <code class="docutils literal notranslate"><span class="pre">q=0.0</span></code> and the same as the maximum if
<code class="docutils literal notranslate"><span class="pre">q=1.0</span></code>.</p>
<p>The optional <em class="xref py py-obj">method</em> parameter specifies the method to use when the
desired quantile lies between two indexes <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">1</span></code>.
In that case, we first determine <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">g</span></code>, a virtual index that lies
between <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code>, where  <code class="docutils literal notranslate"><span class="pre">i</span></code> is the floor and <code class="docutils literal notranslate"><span class="pre">g</span></code> is the
fractional part of the index. The final result is, then, an interpolation
of <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> and <code class="docutils literal notranslate"><span class="pre">a[j]</span></code> based on <code class="docutils literal notranslate"><span class="pre">g</span></code>. During the computation of <code class="docutils literal notranslate"><span class="pre">g</span></code>,
<code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> are modified using correction constants <code class="docutils literal notranslate"><span class="pre">alpha</span></code> and
<code class="docutils literal notranslate"><span class="pre">beta</span></code> whose choices depend on the <code class="docutils literal notranslate"><span class="pre">method</span></code> used. Finally, note that
since Python uses 0-based indexing, the code subtracts another 1 from the
index internally.</p>
<p>The following formula determines the virtual index <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">g</span></code>, the location 
of the quantile in the sorted sample:</p>
<div class="math notranslate nohighlight">
\[i + g = q * ( n - alpha - beta + 1 ) + alpha\]</div>
<p>The different methods then work as follows</p>
<dl class="simple">
<dt>inverted_cdf:</dt><dd><p>method 1 of H&amp;F <a class="reference internal" href="#re01cd3f3acfe-1" id="id2">[1]</a>.
This method gives discontinuous results:</p>
<ul class="simple">
<li><p>if g &gt; 0 ; then take j</p></li>
<li><p>if g = 0 ; then take i</p></li>
</ul>
</dd>
<dt>averaged_inverted_cdf:</dt><dd><p>method 2 of H&amp;F <a class="reference internal" href="#re01cd3f3acfe-1" id="id3">[1]</a>.
This method gives discontinuous results:</p>
<ul class="simple">
<li><p>if g &gt; 0 ; then take j</p></li>
<li><p>if g = 0 ; then average between bounds</p></li>
</ul>
</dd>
<dt>closest_observation:</dt><dd><p>method 3 of H&amp;F <a class="reference internal" href="#re01cd3f3acfe-1" id="id4">[1]</a>.
This method gives discontinuous results:</p>
<ul class="simple">
<li><p>if g &gt; 0 ; then take j</p></li>
<li><p>if g = 0 and index is odd ; then take j</p></li>
<li><p>if g = 0 and index is even ; then take i</p></li>
</ul>
</dd>
<dt>interpolated_inverted_cdf:</dt><dd><p>method 4 of H&amp;F <a class="reference internal" href="#re01cd3f3acfe-1" id="id5">[1]</a>.
This method gives continuous results using:</p>
<ul class="simple">
<li><p>alpha = 0</p></li>
<li><p>beta = 1</p></li>
</ul>
</dd>
<dt>hazen:</dt><dd><p>method 5 of H&amp;F <a class="reference internal" href="#re01cd3f3acfe-1" id="id6">[1]</a>.
This method gives continuous results using:</p>
<ul class="simple">
<li><p>alpha = 1/2</p></li>
<li><p>beta = 1/2</p></li>
</ul>
</dd>
<dt>weibull:</dt><dd><p>method 6 of H&amp;F <a class="reference internal" href="#re01cd3f3acfe-1" id="id7">[1]</a>.
This method gives continuous results using:</p>
<ul class="simple">
<li><p>alpha = 0</p></li>
<li><p>beta = 0</p></li>
</ul>
</dd>
<dt>linear:</dt><dd><p>method 7 of H&amp;F <a class="reference internal" href="#re01cd3f3acfe-1" id="id8">[1]</a>.
This method gives continuous results using:</p>
<ul class="simple">
<li><p>alpha = 1</p></li>
<li><p>beta = 1</p></li>
</ul>
</dd>
<dt>median_unbiased:</dt><dd><p>method 8 of H&amp;F <a class="reference internal" href="#re01cd3f3acfe-1" id="id9">[1]</a>.
This method is probably the best method if the sample
distribution function is unknown (see reference).
This method gives continuous results using:</p>
<ul class="simple">
<li><p>alpha = 1/3</p></li>
<li><p>beta = 1/3</p></li>
</ul>
</dd>
<dt>normal_unbiased:</dt><dd><p>method 9 of H&amp;F <a class="reference internal" href="#re01cd3f3acfe-1" id="id10">[1]</a>.
This method is probably the best method if the sample
distribution function is known to be normal.
This method gives continuous results using:</p>
<ul class="simple">
<li><p>alpha = 3/8</p></li>
<li><p>beta = 3/8</p></li>
</ul>
</dd>
<dt>lower:</dt><dd><p>NumPy method kept for backwards compatibility.
Takes <code class="docutils literal notranslate"><span class="pre">i</span></code> as the interpolation point.</p>
</dd>
<dt>higher:</dt><dd><p>NumPy method kept for backwards compatibility.
Takes <code class="docutils literal notranslate"><span class="pre">j</span></code> as the interpolation point.</p>
</dd>
<dt>nearest:</dt><dd><p>NumPy method kept for backwards compatibility.
Takes <code class="docutils literal notranslate"><span class="pre">i</span></code> or <code class="docutils literal notranslate"><span class="pre">j</span></code>, whichever is nearest.</p>
</dd>
<dt>midpoint:</dt><dd><p>NumPy method kept for backwards compatibility.
Uses <code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">+</span> <span class="pre">j)</span> <span class="pre">/</span> <span class="pre">2</span></code>.</p>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="re01cd3f3acfe-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id1">1</a>,<a role="doc-backlink" href="#id2">2</a>,<a role="doc-backlink" href="#id3">3</a>,<a role="doc-backlink" href="#id4">4</a>,<a role="doc-backlink" href="#id5">5</a>,<a role="doc-backlink" href="#id6">6</a>,<a role="doc-backlink" href="#id7">7</a>,<a role="doc-backlink" href="#id8">8</a>,<a role="doc-backlink" href="#id9">9</a>,<a role="doc-backlink" href="#id10">10</a>)</span>
<p>R. J. Hyndman and Y. Fan,
“Sample quantiles in statistical packages,”
The American Statistician, 50(4), pp. 361-365, 1996</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[10,  7,  4],</span>
<span class="go">       [ 3,  2,  1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="go">3.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([6.5, 4.5, 2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[7.],</span>
<span class="go">       [2.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
<span class="go">array([6.5, 4.5, 2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">array([6.5, 4.5, 2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>See also <a class="reference internal" href="numpy.percentile.html#numpy.percentile" title="numpy.percentile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.percentile</span></code></a> for a visualization of most methods.</p>
</dd></dl>

