
<h1>numpy.in1d<a class="headerlink" href="#numpy-in1d" title="Permalink to this heading">#</a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="numpy.in1d">
<span class="sig-prename descclassname"><span class="pre">numpy.</span></span><span class="sig-name descname"><span class="pre">in1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ar1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ar2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_unique</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/numpy/numpy/blob/v1.24.0/numpy/lib/arraysetops.py#L524-L742"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#numpy.in1d" title="Permalink to this definition">#</a></dt>
<dd><p>Test whether each element of a 1-D array is also present in a second array.</p>
<p>Returns a boolean array the same length as <em class="xref py py-obj">ar1</em> that is True
where an element of <em class="xref py py-obj">ar1</em> is in <em class="xref py py-obj">ar2</em> and False otherwise.</p>
<p>We recommend using <a class="reference internal" href="numpy.isin.html#numpy.isin" title="numpy.isin"><code class="xref py py-func docutils literal notranslate"><span class="pre">isin</span></code></a> instead of <a class="reference internal" href="#numpy.in1d" title="numpy.in1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in1d</span></code></a> for new code.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>ar1</strong><span class="classifier">(M,) array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>ar2</strong><span class="classifier">array_like</span></dt><dd><p>The values against which to test each value of <em class="xref py py-obj">ar1</em>.</p>
</dd>
<dt><strong>assume_unique</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, the input arrays are both assumed to be unique, which
can speed up the calculation.  Default is False.</p>
</dd>
<dt><strong>invert</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, the values in the returned array are inverted (that is,
False where an element of <em class="xref py py-obj">ar1</em> is in <em class="xref py py-obj">ar2</em> and True otherwise).
Default is False. <code class="docutils literal notranslate"><span class="pre">np.in1d(a,</span> <span class="pre">b,</span> <span class="pre">invert=True)</span></code> is equivalent
to (but is faster than) <code class="docutils literal notranslate"><span class="pre">np.invert(in1d(a,</span> <span class="pre">b))</span></code>.</p>
</dd>
<dt><strong>kind</strong><span class="classifier">{None, ‘sort’, ‘table’}, optional</span></dt><dd><p>The algorithm to use. This will not affect the final result,
but will affect the speed and memory use. The default, None,
will select automatically based on memory considerations.</p>
<ul class="simple">
<li><p>If ‘sort’, will use a mergesort-based approach. This will have
a memory usage of roughly 6 times the sum of the sizes of
<em class="xref py py-obj">ar1</em> and <em class="xref py py-obj">ar2</em>, not accounting for size of dtypes.</p></li>
<li><p>If ‘table’, will use a lookup table approach similar
to a counting sort. This is only available for boolean and
integer arrays. This will have a memory usage of the
size of <em class="xref py py-obj">ar1</em> plus the max-min value of <em class="xref py py-obj">ar2</em>. <em class="xref py py-obj">assume_unique</em>
has no effect when the ‘table’ option is used.</p></li>
<li><p>If None, will automatically choose ‘table’ if
the required memory allocation is less than or equal to
6 times the sum of the sizes of <em class="xref py py-obj">ar1</em> and <em class="xref py py-obj">ar2</em>,
otherwise will use ‘sort’. This is done to not use
a large amount of memory by default, even though
‘table’ may be faster in most cases. If ‘table’ is chosen,
<em class="xref py py-obj">assume_unique</em> will have no effect.</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>in1d</strong><span class="classifier">(M,) ndarray, bool</span></dt><dd><p>The values <em class="xref py py-obj">ar1[in1d]</em> are in <em class="xref py py-obj">ar2</em>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="numpy.isin.html#numpy.isin" title="numpy.isin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isin</span></code></a></dt><dd><p>Version of this function that preserves the shape of ar1.</p>
</dd>
<dt><a class="reference internal" href="numpy.lib.arraysetops.html#module-numpy.lib.arraysetops" title="numpy.lib.arraysetops"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.lib.arraysetops</span></code></a></dt><dd><p>Module with a number of other functions for performing set operations on arrays.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p><a class="reference internal" href="#numpy.in1d" title="numpy.in1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in1d</span></code></a> can be considered as an element-wise function version of the
python keyword <em class="xref py py-obj">in</em>, for 1-D sequences. <code class="docutils literal notranslate"><span class="pre">in1d(a,</span> <span class="pre">b)</span></code> is roughly
equivalent to <code class="docutils literal notranslate"><span class="pre">np.array([item</span> <span class="pre">in</span> <span class="pre">b</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">a])</span></code>.
However, this idea fails if <em class="xref py py-obj">ar2</em> is a set, or similar (non-sequence)
container:  As <code class="docutils literal notranslate"><span class="pre">ar2</span></code> is converted to an array, in those cases
<code class="docutils literal notranslate"><span class="pre">asarray(ar2)</span></code> is an object array rather than the expected array of
contained values.</p>
<p>Using <code class="docutils literal notranslate"><span class="pre">kind='table'</span></code> tends to be faster than <em class="xref py py-obj">kind=’sort’</em> if the
following relationship is true:
<code class="docutils literal notranslate"><span class="pre">log10(len(ar2))</span> <span class="pre">&gt;</span> <span class="pre">(log10(max(ar2)-min(ar2))</span> <span class="pre">-</span> <span class="pre">2.27)</span> <span class="pre">/</span> <span class="pre">0.927</span></code>,
but may use greater memory. The default value for <em class="xref py py-obj">kind</em> will
be automatically selected based only on memory usage, so one may
manually set <code class="docutils literal notranslate"><span class="pre">kind='table'</span></code> if memory constraints can be relaxed.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.4.0.</span></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">states</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span>
<span class="go">array([ True, False,  True, False,  True])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
<span class="go">array([0, 2, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span>
<span class="go">array([False,  True, False,  True, False])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
<span class="go">array([1, 5])</span>
</pre></div>
</div>
</dd></dl>

