
<h1>numpy.shares_memory<a class="headerlink" href="#numpy-shares-memory" title="Permalink to this heading">#</a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="numpy.shares_memory">
<span class="sig-prename descclassname"><span class="pre">numpy.</span></span><span class="sig-name descname"><span class="pre">shares_memory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_work</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.shares_memory" title="Permalink to this definition">#</a></dt>
<dd><p>Determine if two arrays share memory.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function can be exponentially slow for some inputs, unless
<em class="xref py py-obj">max_work</em> is set to a finite number or <code class="docutils literal notranslate"><span class="pre">MAY_SHARE_BOUNDS</span></code>.
If in doubt, use <a class="reference internal" href="numpy.may_share_memory.html#numpy.may_share_memory" title="numpy.may_share_memory"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.may_share_memory</span></code></a> instead.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>a, b</strong><span class="classifier">ndarray</span></dt><dd><p>Input arrays</p>
</dd>
<dt><strong>max_work</strong><span class="classifier">int, optional</span></dt><dd><p>Effort to spend on solving the overlap problem (maximum number
of candidate solutions to consider). The following special
values are recognized:</p>
<dl class="simple">
<dt>max_work=MAY_SHARE_EXACT  (default)</dt><dd><p>The problem is solved exactly. In this case, the function returns
True only if there is an element shared between the arrays. Finding
the exact solution may take extremely long in some cases.</p>
</dd>
<dt>max_work=MAY_SHARE_BOUNDS</dt><dd><p>Only the memory bounds of a and b are checked.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">bool</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.TooHardError</dt><dd><p>Exceeded max_work.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="numpy.may_share_memory.html#numpy.may_share_memory" title="numpy.may_share_memory"><code class="xref py py-obj docutils literal notranslate"><span class="pre">may_share_memory</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shares_memory</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]))</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shares_memory</span><span class="p">(</span><span class="n">x</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shares_memory</span><span class="p">(</span><span class="n">x</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Checking whether two arrays share memory is NP-complete, and
runtime may increase exponentially in the number of
dimensions. Hence, <em class="xref py py-obj">max_work</em> should generally be set to a finite
number, as it is possible to construct examples that take
extremely long to run:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.lib.stride_tricks</span> <span class="kn">import</span> <span class="n">as_strided</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">192163377</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">as_strided</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="mi">36674</span><span class="p">,</span> <span class="mi">61119</span><span class="p">,</span> <span class="mi">85569</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1049</span><span class="p">,</span> <span class="mi">1049</span><span class="p">,</span> <span class="mi">1049</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">as_strided</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">64023025</span><span class="p">:],</span> <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="mi">12223</span><span class="p">,</span> <span class="mi">12224</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1049</span><span class="p">,</span> <span class="mi">1049</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shares_memory</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">max_work</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">numpy.TooHardError</span>: <span class="n">Exceeded max_work</span>
</pre></div>
</div>
<p>Running <code class="docutils literal notranslate"><span class="pre">np.shares_memory(x1,</span> <span class="pre">x2)</span></code> without <em class="xref py py-obj">max_work</em> set takes
around 1 minute for this case. It is possible to find problems
that take still significantly longer.</p>
</dd></dl>

