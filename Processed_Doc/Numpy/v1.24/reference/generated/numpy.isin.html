
<h1>numpy.isin<a class="headerlink" href="#numpy-isin" title="Permalink to this heading">#</a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="numpy.isin">
<span class="sig-prename descclassname"><span class="pre">numpy.</span></span><span class="sig-name descname"><span class="pre">isin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_elements</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_unique</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/numpy/numpy/blob/v1.24.0/numpy/lib/arraysetops.py#L750-L875"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#numpy.isin" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">element</span> <span class="pre">in</span> <span class="pre">test_elements</span></code>, broadcasting over <em class="xref py py-obj">element</em> only.
Returns a boolean array of the same shape as <em class="xref py py-obj">element</em> that is True
where an element of <em class="xref py py-obj">element</em> is in <em class="xref py py-obj">test_elements</em> and False otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>element</strong><span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>test_elements</strong><span class="classifier">array_like</span></dt><dd><p>The values against which to test each value of <em class="xref py py-obj">element</em>.
This argument is flattened if it is an array or array_like.
See notes for behavior with non-array-like parameters.</p>
</dd>
<dt><strong>assume_unique</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, the input arrays are both assumed to be unique, which
can speed up the calculation.  Default is False.</p>
</dd>
<dt><strong>invert</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, the values in the returned array are inverted, as if
calculating <em class="xref py py-obj">element not in test_elements</em>. Default is False.
<code class="docutils literal notranslate"><span class="pre">np.isin(a,</span> <span class="pre">b,</span> <span class="pre">invert=True)</span></code> is equivalent to (but faster
than) <code class="docutils literal notranslate"><span class="pre">np.invert(np.isin(a,</span> <span class="pre">b))</span></code>.</p>
</dd>
<dt><strong>kind</strong><span class="classifier">{None, ‘sort’, ‘table’}, optional</span></dt><dd><p>The algorithm to use. This will not affect the final result,
but will affect the speed and memory use. The default, None,
will select automatically based on memory considerations.</p>
<ul class="simple">
<li><p>If ‘sort’, will use a mergesort-based approach. This will have
a memory usage of roughly 6 times the sum of the sizes of
<em class="xref py py-obj">ar1</em> and <em class="xref py py-obj">ar2</em>, not accounting for size of dtypes.</p></li>
<li><p>If ‘table’, will use a lookup table approach similar
to a counting sort. This is only available for boolean and
integer arrays. This will have a memory usage of the
size of <em class="xref py py-obj">ar1</em> plus the max-min value of <em class="xref py py-obj">ar2</em>. <em class="xref py py-obj">assume_unique</em>
has no effect when the ‘table’ option is used.</p></li>
<li><p>If None, will automatically choose ‘table’ if
the required memory allocation is less than or equal to
6 times the sum of the sizes of <em class="xref py py-obj">ar1</em> and <em class="xref py py-obj">ar2</em>,
otherwise will use ‘sort’. This is done to not use
a large amount of memory by default, even though
‘table’ may be faster in most cases. If ‘table’ is chosen,
<em class="xref py py-obj">assume_unique</em> will have no effect.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>isin</strong><span class="classifier">ndarray, bool</span></dt><dd><p>Has the same shape as <em class="xref py py-obj">element</em>. The values <em class="xref py py-obj">element[isin]</em>
are in <em class="xref py py-obj">test_elements</em>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="numpy.in1d.html#numpy.in1d" title="numpy.in1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in1d</span></code></a></dt><dd><p>Flattened version of this function.</p>
</dd>
<dt><a class="reference internal" href="numpy.lib.arraysetops.html#module-numpy.lib.arraysetops" title="numpy.lib.arraysetops"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.lib.arraysetops</span></code></a></dt><dd><p>Module with a number of other functions for performing set operations on arrays.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p><a class="reference internal" href="#numpy.isin" title="numpy.isin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isin</span></code></a> is an element-wise function version of the python keyword <em class="xref py py-obj">in</em>.
<code class="docutils literal notranslate"><span class="pre">isin(a,</span> <span class="pre">b)</span></code> is roughly equivalent to
<code class="docutils literal notranslate"><span class="pre">np.array([item</span> <span class="pre">in</span> <span class="pre">b</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">a])</span></code> if <em class="xref py py-obj">a</em> and <em class="xref py py-obj">b</em> are 1-D sequences.</p>
<p><em class="xref py py-obj">element</em> and <em class="xref py py-obj">test_elements</em> are converted to arrays if they are not
already. If <em class="xref py py-obj">test_elements</em> is a set (or other non-sequence collection)
it will be converted to an object array with one element, rather than an
array of the values contained in <em class="xref py py-obj">test_elements</em>. This is a consequence
of the <a class="reference internal" href="numpy.array.html#numpy.array" title="numpy.array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">array</span></code></a> constructor’s way of handling non-sequence collections.
Converting the set to a list usually gives the desired behavior.</p>
<p>Using <code class="docutils literal notranslate"><span class="pre">kind='table'</span></code> tends to be faster than <em class="xref py py-obj">kind=’sort’</em> if the
following relationship is true:
<code class="docutils literal notranslate"><span class="pre">log10(len(ar2))</span> <span class="pre">&gt;</span> <span class="pre">(log10(max(ar2)-min(ar2))</span> <span class="pre">-</span> <span class="pre">2.27)</span> <span class="pre">/</span> <span class="pre">0.927</span></code>,
but may use greater memory. The default value for <em class="xref py py-obj">kind</em> will
be automatically selected based only on memory usage, so one may
manually set <code class="docutils literal notranslate"><span class="pre">kind='table'</span></code> if memory constraints can be relaxed.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.13.0.</span></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">element</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">element</span>
<span class="go">array([[0, 2],</span>
<span class="go">       [4, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test_elements</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">test_elements</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span>
<span class="go">array([[False,  True],</span>
<span class="go">       [ True, False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">element</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
<span class="go">array([2, 4])</span>
</pre></div>
</div>
<p>The indices of the matched values can be obtained with <a class="reference internal" href="numpy.nonzero.html#numpy.nonzero" title="numpy.nonzero"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nonzero</span></code></a>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
<span class="go">(array([0, 1]), array([1, 0]))</span>
</pre></div>
</div>
<p>The test can also be inverted:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">test_elements</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span>
<span class="go">array([[ True, False],</span>
<span class="go">       [False,  True]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">element</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
<span class="go">array([0, 6])</span>
</pre></div>
</div>
<p>Because of how <a class="reference internal" href="numpy.array.html#numpy.array" title="numpy.array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">array</span></code></a> handles sets, the following does not
work as expected:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">test_set</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">test_set</span><span class="p">)</span>
<span class="go">array([[False, False],</span>
<span class="go">       [False, False]])</span>
</pre></div>
</div>
<p>Casting the set to a list gives the expected result:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">test_set</span><span class="p">))</span>
<span class="go">array([[False,  True],</span>
<span class="go">       [ True, False]])</span>
</pre></div>
</div>
</dd></dl>

