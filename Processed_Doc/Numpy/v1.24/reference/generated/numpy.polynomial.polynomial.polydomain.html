
<h1>numpy.polynomial.polynomial.polydomain<a class="headerlink" href="#numpy-polynomial-polynomial-polydomain" title="Permalink to this heading">#</a></h1>
<dl class="py data">
<dt class="sig sig-object py" id="numpy.polynomial.polynomial.polydomain">
<span class="sig-prename descclassname"><span class="pre">polynomial.polynomial.</span></span><span class="sig-name descname"><span class="pre">polydomain</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">array([-1,</span>&#160; <span class="pre">1])</span></em><a class="headerlink" href="#numpy.polynomial.polynomial.polydomain" title="Permalink to this definition">#</a></dt>
<dd><p>An array object represents a multidimensional, homogeneous array
of fixed-size items.  An associated data-type object describes the
format of each element in the array (its byte-order, how many bytes it
occupies in memory, whether it is an integer, a floating point number,
or something else, etc.)</p>
<p>Arrays should be constructed using <a class="reference internal" href="numpy.array.html#numpy.array" title="numpy.array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">array</span></code></a>, <a class="reference internal" href="numpy.zeros.html#numpy.zeros" title="numpy.zeros"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros</span></code></a> or <a class="reference internal" href="numpy.empty.html#numpy.empty" title="numpy.empty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">empty</span></code></a> (refer
to the See Also section below).  The parameters given here refer to
a low-level method (<em class="xref py py-obj">ndarray(…)</em>) for instantiating an array.</p>
<p>For more information, refer to the <a class="reference internal" href="../index.html#module-numpy" title="numpy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span></code></a> module and examine the
methods and attributes of an array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>(for the __new__ method; see Notes below)</strong></dt><dd></dd>
<dt><strong>shape</strong><span class="classifier">tuple of ints</span></dt><dd><p>Shape of created array.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>Any object that can be interpreted as a numpy data type.</p>
</dd>
<dt><strong>buffer</strong><span class="classifier">object exposing buffer interface, optional</span></dt><dd><p>Used to fill the array with data.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int, optional</span></dt><dd><p>Offset of array data in buffer.</p>
</dd>
<dt><strong>strides</strong><span class="classifier">tuple of ints, optional</span></dt><dd><p>Strides of data in memory.</p>
</dd>
<dt><strong>order</strong><span class="classifier">{‘C’, ‘F’}, optional</span></dt><dd><p>Row-major (C-style) or column-major (Fortran-style) order.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="numpy.array.html#numpy.array" title="numpy.array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">array</span></code></a></dt><dd><p>Construct an array.</p>
</dd>
<dt><a class="reference internal" href="numpy.zeros.html#numpy.zeros" title="numpy.zeros"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros</span></code></a></dt><dd><p>Create an array, each element of which is zero.</p>
</dd>
<dt><a class="reference internal" href="numpy.empty.html#numpy.empty" title="numpy.empty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">empty</span></code></a></dt><dd><p>Create an array, but leave its allocated memory unchanged (i.e., it contains “garbage”).</p>
</dd>
<dt><a class="reference internal" href="numpy.dtype.html#numpy.dtype" title="numpy.dtype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></a></dt><dd><p>Create a data-type.</p>
</dd>
<dt><a class="reference internal" href="../typing.html#numpy.typing.NDArray" title="numpy.typing.NDArray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.typing.NDArray</span></code></a></dt><dd><p>An ndarray alias <a class="reference external" href="https://docs.python.org/3/glossary.html#term-generic-type" title="(in Python v3.11)"><span class="xref std std-term">generic</span></a> w.r.t. its <a class="reference internal" href="numpy.dtype.type.html#numpy.dtype.type" title="numpy.dtype.type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype.type</span></code></a>.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>There are two modes of creating an array using <code class="docutils literal notranslate"><span class="pre">__new__</span></code>:</p>
<ol class="arabic simple">
<li><p>If <em class="xref py py-obj">buffer</em> is None, then only <a class="reference internal" href="numpy.shape.html#numpy.shape" title="numpy.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></a>, <a class="reference internal" href="numpy.dtype.html#numpy.dtype" title="numpy.dtype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></a>, and <em class="xref py py-obj">order</em>
are used.</p></li>
<li><p>If <em class="xref py py-obj">buffer</em> is an object exposing the buffer interface, then
all keywords are interpreted.</p></li>
</ol>
<p>No <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method is needed because the array is fully initialized
after the <code class="docutils literal notranslate"><span class="pre">__new__</span></code> method.</p>
<p class="rubric">Examples</p>
<p>These examples illustrate the low-level <a class="reference internal" href="numpy.ndarray.html#numpy.ndarray" title="numpy.ndarray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndarray</span></code></a> constructor.  Refer
to the <em class="xref py py-obj">See Also</em> section above for easier ways of constructing an
ndarray.</p>
<p>First mode, <em class="xref py py-obj">buffer</em> is None:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">array([[0.0e+000, 0.0e+000], # random</span>
<span class="go">       [     nan, 2.5e-323]])</span>
</pre></div>
</div>
<p>Second mode:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">buffer</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span>
<span class="gp">... </span>           <span class="n">offset</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">()</span><span class="o">.</span><span class="n">itemsize</span><span class="p">,</span>
<span class="gp">... </span>           <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="c1"># offset = 1*itemsize, i.e. skip first element</span>
<span class="go">array([2, 3])</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>T</strong><span class="classifier">ndarray</span></dt><dd><p>Transpose of the array.</p>
</dd>
<dt><strong>data</strong><span class="classifier">buffer</span></dt><dd><p>The array’s elements, in memory.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">dtype object</span></dt><dd><p>Describes the format of the elements in the array.</p>
</dd>
<dt><strong>flags</strong><span class="classifier">dict</span></dt><dd><p>Dictionary containing information related to memory use, e.g.,
‘C_CONTIGUOUS’, ‘OWNDATA’, ‘WRITEABLE’, etc.</p>
</dd>
<dt><strong>flat</strong><span class="classifier">numpy.flatiter object</span></dt><dd><p>Flattened version of the array as an iterator.  The iterator
allows assignments, e.g., <code class="docutils literal notranslate"><span class="pre">x.flat</span> <span class="pre">=</span> <span class="pre">3</span></code> (See <a class="reference internal" href="numpy.ndarray.flat.html#numpy.ndarray.flat" title="numpy.ndarray.flat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndarray.flat</span></code></a> for
assignment examples; TODO).</p>
</dd>
<dt><strong>imag</strong><span class="classifier">ndarray</span></dt><dd><p>Imaginary part of the array.</p>
</dd>
<dt><strong>real</strong><span class="classifier">ndarray</span></dt><dd><p>Real part of the array.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int</span></dt><dd><p>Number of elements in the array.</p>
</dd>
<dt><strong>itemsize</strong><span class="classifier">int</span></dt><dd><p>The memory use of each array element in bytes.</p>
</dd>
<dt><strong>nbytes</strong><span class="classifier">int</span></dt><dd><p>The total number of bytes required to store the array data,
i.e., <code class="docutils literal notranslate"><span class="pre">itemsize</span> <span class="pre">*</span> <span class="pre">size</span></code>.</p>
</dd>
<dt><strong>ndim</strong><span class="classifier">int</span></dt><dd><p>The array’s number of dimensions.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">tuple of ints</span></dt><dd><p>Shape of the array.</p>
</dd>
<dt><strong>strides</strong><span class="classifier">tuple of ints</span></dt><dd><p>The step-size required to move from one element to the next in
memory. For example, a contiguous <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">4)</span></code> array of type
<code class="docutils literal notranslate"><span class="pre">int16</span></code> in C-order has strides <code class="docutils literal notranslate"><span class="pre">(8,</span> <span class="pre">2)</span></code>.  This implies that
to move from element to element in memory requires jumps of 2 bytes.
To move from row-to-row, one needs to jump 8 bytes at a time
(<code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">4</span></code>).</p>
</dd>
<dt><strong>ctypes</strong><span class="classifier">ctypes object</span></dt><dd><p>Class containing properties of the array needed for interaction
with ctypes.</p>
</dd>
<dt><strong>base</strong><span class="classifier">ndarray</span></dt><dd><p>If the array is a view into another array, that array is its <em class="xref py py-obj">base</em>
(unless that array is also a view).  The <em class="xref py py-obj">base</em> array is where the
array data is actually stored.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

