
<h1>numpy.finfo<a class="headerlink" href="#numpy-finfo" title="Permalink to this heading">#</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="numpy.finfo">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">numpy.</span></span><span class="sig-name descname"><span class="pre">finfo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/numpy/numpy/blob/v1.24.0/numpy/__init__.py"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#numpy.finfo" title="Permalink to this definition">#</a></dt>
<dd><p>Machine limits for floating point types.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">float, dtype, or instance</span></dt><dd><p>Kind of floating point or complex floating point
data-type about which to get information.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">MachAr</span></code></dt><dd><p>The implementation of the tests that produce this information.</p>
</dd>
<dt><a class="reference internal" href="numpy.iinfo.html#numpy.iinfo" title="numpy.iinfo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iinfo</span></code></a></dt><dd><p>The equivalent for integer data types.</p>
</dd>
<dt><a class="reference internal" href="numpy.spacing.html#numpy.spacing" title="numpy.spacing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spacing</span></code></a></dt><dd><p>The distance between a value and the nearest adjacent number</p>
</dd>
<dt><a class="reference internal" href="numpy.nextafter.html#numpy.nextafter" title="numpy.nextafter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nextafter</span></code></a></dt><dd><p>The next floating point value after x1 towards x2</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For developers of NumPy: do not instantiate this at the module level.
The initial calculation of these parameters is expensive and negatively
impacts import times.  These objects are cached, so calling <code class="docutils literal notranslate"><span class="pre">finfo()</span></code>
repeatedly inside your functions is not a problem.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">smallest_normal</span></code> is not actually the smallest positive
representable value in a NumPy floating point type. As in the IEEE-754
standard <a class="reference internal" href="#r2ee89c7f792a-1" id="id1">[1]</a>, NumPy floating point types make use of subnormal numbers to
fill the gap between 0 and <code class="docutils literal notranslate"><span class="pre">smallest_normal</span></code>. However, subnormal numbers
may have significantly reduced precision <a class="reference internal" href="#r2ee89c7f792a-2" id="id2">[2]</a>.</p>
<p>This function can also be used for complex data types as well. If used,
the output will be the same as the corresponding real float type
(e.g. numpy.finfo(numpy.csingle) is the same as numpy.finfo(numpy.single)).
However, the output is true for the real and imaginary components.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r2ee89c7f792a-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>IEEE Standard for Floating-Point Arithmetic, IEEE Std 754-2008,
pp.1-70, 2008, <a class="reference external" href="http://www.doi.org/10.1109/IEEESTD.2008.4610935">http://www.doi.org/10.1109/IEEESTD.2008.4610935</a></p>
</div>
<div class="citation" id="r2ee89c7f792a-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>Wikipedia, “Denormal Numbers”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Denormal_number">https://en.wikipedia.org/wiki/Denormal_number</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;float64&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;float32&#39;)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bits</strong><span class="classifier">int</span></dt><dd><p>The number of bits occupied by the type.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">dtype</span></dt><dd><p>Returns the dtype for which <a class="reference internal" href="#numpy.finfo" title="numpy.finfo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">finfo</span></code></a> returns information. For complex
input, the returned dtype is the associated <code class="docutils literal notranslate"><span class="pre">float*</span></code> dtype for its
real and complex components.</p>
</dd>
<dt><strong>eps</strong><span class="classifier">float</span></dt><dd><p>The difference between 1.0 and the next smallest representable float
larger than 1.0. For example, for 64-bit binary floats in the IEEE-754
standard, <code class="docutils literal notranslate"><span class="pre">eps</span> <span class="pre">=</span> <span class="pre">2**-52</span></code>, approximately 2.22e-16.</p>
</dd>
<dt><strong>epsneg</strong><span class="classifier">float</span></dt><dd><p>The difference between 1.0 and the next smallest representable float
less than 1.0. For example, for 64-bit binary floats in the IEEE-754
standard, <code class="docutils literal notranslate"><span class="pre">epsneg</span> <span class="pre">=</span> <span class="pre">2**-53</span></code>, approximately 1.11e-16.</p>
</dd>
<dt><strong>iexp</strong><span class="classifier">int</span></dt><dd><p>The number of bits in the exponent portion of the floating point
representation.</p>
</dd>
<dt><a class="reference internal" href="numpy.finfo.machar.html#numpy.finfo.machar" title="numpy.finfo.machar"><code class="xref py py-obj docutils literal notranslate"><span class="pre">machar</span></code></a><span class="classifier">MachAr</span></dt><dd><p>The object which calculated these parameters and holds more detailed information.</p>
</dd>
<dt><strong>machep</strong><span class="classifier">int</span></dt><dd><p>The exponent that yields <em class="xref py py-obj">eps</em>.</p>
</dd>
<dt><strong>max</strong><span class="classifier">floating point number of the appropriate type</span></dt><dd><p>The largest representable number.</p>
</dd>
<dt><strong>maxexp</strong><span class="classifier">int</span></dt><dd><p>The smallest positive power of the base (2) that causes overflow.</p>
</dd>
<dt><strong>min</strong><span class="classifier">floating point number of the appropriate type</span></dt><dd><p>The smallest representable number, typically <code class="docutils literal notranslate"><span class="pre">-max</span></code>.</p>
</dd>
<dt><strong>minexp</strong><span class="classifier">int</span></dt><dd><p>The most negative power of the base (2) consistent with there
being no leading 0’s in the mantissa.</p>
</dd>
<dt><strong>negep</strong><span class="classifier">int</span></dt><dd><p>The exponent that yields <em class="xref py py-obj">epsneg</em>.</p>
</dd>
<dt><strong>nexp</strong><span class="classifier">int</span></dt><dd><p>The number of bits in the exponent including its sign and bias.</p>
</dd>
<dt><strong>nmant</strong><span class="classifier">int</span></dt><dd><p>The number of bits in the mantissa.</p>
</dd>
<dt><strong>precision</strong><span class="classifier">int</span></dt><dd><p>The approximate number of decimal digits to which this kind of
float is precise.</p>
</dd>
<dt><strong>resolution</strong><span class="classifier">floating point number of the appropriate type</span></dt><dd><p>The approximate decimal resolution of this type, i.e.,
<code class="docutils literal notranslate"><span class="pre">10**-precision</span></code>.</p>
</dd>
<dt><a class="reference internal" href="numpy.finfo.tiny.html#numpy.finfo.tiny" title="numpy.finfo.tiny"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tiny</span></code></a><span class="classifier">float</span></dt><dd><p>Return the value for tiny, alias of smallest_normal.</p>
</dd>
<dt><a class="reference internal" href="numpy.finfo.smallest_normal.html#numpy.finfo.smallest_normal" title="numpy.finfo.smallest_normal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">smallest_normal</span></code></a><span class="classifier">float</span></dt><dd><p>Return the value for the smallest normal.</p>
</dd>
<dt><strong>smallest_subnormal</strong><span class="classifier">float</span></dt><dd><p>The smallest positive floating point number with 0 as leading bit in
the mantissa following IEEE-754.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

